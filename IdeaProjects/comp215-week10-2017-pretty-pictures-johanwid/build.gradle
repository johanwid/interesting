// This "gradle" file specifies how your program gets compiled, what libraries it uses, and a bunch of other
// useful things. DO NOT EDIT THIS FILE!

// Engineering notes: this file is actually a program written in the Groovy programming language, which
// is yet another programming language that targets the Java virtual machine, with an emphasis on dynamic
// types rather than static types. In short, Groovy is somewhere in between Python and Java. There are
// a bunch of neat things going on here. Groovy makes it easy to define new commands which look like native
// commands in the programming language; you'll see these in action below. That means that Groovy makes
// it easy to define a "domain specific language" (DSL) for just about anything, which is exactly what
// Gradle is doing here. Some of these commands are backed by Groovy code, while others are backed by Java
// code, which are all hooked in by the various "plugins".

// Gradle's Java plugin is the reason we're here at all. Gradle knows how to compile Java and run your
// unit tests. Via additional plugins, we can then add in code coverage requirements, CheckStyle requirements,
// and whatever else we want. This helps your graders verify that your projects satisfy each week's
// requirements without having to actually fire up IntelliJ.

// There are several other tools that do similar things to Gradle. You'll occasionally run into Ant and
// Maven, both of which use a far less pleasant XML syntax to describe things similar to what you see
// here. Also, if you scroll to the bottom, you'll see a bunch of external library specifications. All
// of those are managed by MavenCentral, a web service that takes a library name and points your computer
// at the relevant code to download.

// So why is Comp215 using Gradle? We've based Comp215's coding environment (IntelliJ, Java, Gradle, etc.)
// on the "standard" Android coding environment, as encouraged by Google. It's not that we're trying to
// turn Comp215 students into Android programmers. Rather, we're riding on Google's coattails. As Google,
// JetBrains, and other companies invest significant effort in improving the toolchain for Android, we
// gain the benefit of those efforts.

// We're not going to teach anything about Groovy or Gradle in Comp215, but you're welcome to read up
// on your own. In particular, you hardly ever have to know much about the Groovy language in order to
// configure Gradle. There's a lot of help to be had on StackOverflow and elsewhere.

// More about Groovy: http://groovy-lang.org/
// More about Gradle: https://gradle.org/

buildscript {
    repositories {
        mavenCentral()

        maven {
            url "https://plugins.gradle.org/m2/"
        }

        maven {
            url "https://oss.sonatype.org/content/repositories/snapshots/"
        }
    }
}

plugins {
    id 'java'
    id 'idea'
    id 'checkstyle'
    id 'jacoco'
    id 'info.solidsoft.pitest' version '1.1.11'
    id 'net.ltgt.errorprone' version '0.0.11'
}

group 'edu.rice'
version '1.0'

allprojects {
    tasks.withType(JavaCompile) {
        sourceCompatibility = '1.8'
        targetCompatibility = '1.8'
    }
}

idea {
    project {
        jdkName = '1.8'
        languageLevel = '1.8'
    }
}

checkstyle {
    toolVersion = '8.1'
    maxWarnings = 0
    maxErrors = 0
}

compileJava {
    options.fork = true
    options.incremental = true
}

// turn on all warnings, except for the ones that are annoying or unhelpful
tasks.withType(JavaCompile) {
    options.compilerArgs << "-Werror" << "-Xlint:all" << "-Xlint:-serial" << "-Xlint:-processing"
}

// set Java flags to use more memory than default so we avoid unnecessary stack overflows
task run(type: JavaExec) {
    jvmArgs = ['-Xss1m', '-Xms256m'] // 1MB stack, 256MB heap
}

////////////////////////////////////////////////////////////////////////////////
// we want to print the date and other useful stuff every time we compile; helpful when looking at logs
import java.time.*
import java.time.format.DateTimeFormatter

task printStuff () {
    // Engineering note: We have no idea what timezone any given student's computer or any given
    // Travis-CI server might be running in, and we want to print these things in a standard way.
    // By asking for the time in Rice's local timezone, we'll get the uniform response that
    // we want. Also, note that these are just calls to the "java.time" classes that are part of Java8.
    // Groovy can call into Java and IntelliJ even does the same sort of auto-complete.

    println "Compilation time: " +
            ZonedDateTime.now(ZoneId.of("America/Chicago")).format(DateTimeFormatter.RFC_1123_DATE_TIME)

    // And, while we're here, we might as well print out the Java version
    println "Gradle JDK: " + System.getProperty("java.version")
}
tasks.compileJava.dependsOn printStuff


////////////////////////////////////////////////////////////////////////////////
// These are gradle actions that lets us launch a JVM for our various different "main" methods.
// https://docs.gradle.org/current/javadoc/org/gradle/api/tasks/JavaExec.html

// Note that these actions, when run from the command-line, they all seem to do the right thing, and you can kill
// off your server by typing Control-C. If you run them from IntelliJ, you'll have to hit the red stop-button.

// Launching a Java command with all the right classpath and library arguments is a pain, so it's nice that Gradle
// will do all the work for us. Also, by saying that these tasks "depend on the classes", that means that Gradle
// will make sure to recompile anything, if necessary, before going on and starting the Java program.

task runHangman (dependsOn: classes, type: JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    main = "edu.rice.week1hangman.Hangman"
    standardInput = System.in
}

task runRPN (dependsOn: classes, type: JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    main = "edu.rice.rpn.RPNCalcServer"
}

task runJavaScriptRepl (dependsOn: classes, type: JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    main = "edu.rice.web.JavaScriptRepl"
}

task runSimpleServer (dependsOn: classes, type: JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    main = "edu.rice.web.SimpleServer"
}

task runPrettyPictures (dependsOn: classes, type: JavaExec) {
    classpath = sourceSets.main.runtimeClasspath
    main = "edu.rice.prettypictures.PrettyPicturesServerSolution"
}

task runPrimeBenchmarking (dependsOn: classes, type: JavaExec) {
    classpath = sourceSets.main.runtimeClasspath

    // Documentation on JVM arguments: http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html
    jvmArgs = ['-Xss320k', // 320KB stack, trying to keep this small
               '-Xmx16g', // 16GB heap maximum (versus 256MB default)
               '-d64', // 64-bit JVM
               // '-XX:+UseG1GC', // "garbage first" garbage collector: the default in Java9, optional in Java8
               '-Xcomp', '-Xbatch', // compile everything up front, no interpreter
               '-XX:+AggressiveOpts', // "aggressive" performance optimizations
    ]

    main = "edu.rice.primes.PrimeBenchmarking"
}

task profilePrimeBenchmarking (dependsOn: classes, type: JavaExec) {
    classpath = sourceSets.main.runtimeClasspath

    // Documentation on Java's profiling support is awful; some details are written up in
    // "profiling-notes.txt". Before you run this, you should edit Primes.FUNCS, which lists the
    // algorithms to be benchmarked, to comment out everything except for the one algorithm you want
    // to profile. You probably also want a more reasonable number for PrimeBenchmarking.MAX_N and
    // there's no reason for BEST_OF_N to be anything other than one.
    //
    // Repeat this for each one, such that you get one "jfr" file per algorithm, which you can then
    // load up and see how it's doing. If you were doing this in industry, where you want repeatable
    // tests without the error-prone nature of editing and recompiling your program, you'd migrate
    // "FUNCS" from the Java source code over to this Gradle file.

    jvmArgs = ['-Xss320k', // 320KB stack, trying to keep this small
               '-Xmx16g', // 16GB heap maximum (versus 256MB default)

               // flags below enable the "Java flight recorder" and dump a runtime profile to the file "primeBench.jfr"
               '-XX:+UnlockCommercialFeatures',
               '-XX:+FlightRecorder',
               '-XX:+UnlockDiagnosticVMOptions',
               '-XX:+DebugNonSafepoints',
               '-XX:FlightRecorderOptions=defaultrecording=true,stackdepth=1024,dumponexit=true,dumponexitpath=primeBench.jfr'
    ]

    main = "edu.rice.primes.PrimeBenchmarking"
}

////////////////////////////////////////////////////////////////////////////////
// This section configures "pitest", a fancy "mutation analysis" engine
// that changes your program hundreds of different ways, under the theory that
// a "good" unit test will fail if your program has a bug in it. http://pitest.org/

pitest {
    // pitest normally suppresses logging library calls from its mutation analysis, since if
    // you delete these calls, they pretty much by definition should have no impact on the resulting
    // computation. This line adds our own logging calls to the list of things to ignore.
    avoidCallsTo = ["edu.rice.util.Log",
                    "edu.rice.web.Utils.logSparkRequest",
                    "edu.rice.util.Option.logIfNone",
                    "edu.rice.util.Try.logIfFailure",
                    "edu.rice.util.Try.logIfFailureVerbose"]
}

////////////////////////////////////////////////////////////////////////////////
// This section configures JaCoCo (Java Code Coverage). For some assignments, we'll have minimum code
// coverage requirements. JaCoCo can enforce this as part of 'gradle check'.

jacoco {
    toolVersion = "0.7.9"
}

jacocoTestReport {
    reports {
        xml.enabled = false
        csv.enabled = false
        html.destination "${buildDir}/reports/jacoco"
    }
}

test {
    jacoco {
        append = false
    }
}

// Documentation for the rules is only available for Jacoco as it integrates with Ant, which
// is an older tool that does the same sort of thing as Gradle. Anyway, you can read this to
// understand the rules below. http://www.eclemma.org/jacoco/trunk/doc/ant.html
jacocoTestCoverageVerification {
    violationRules {
        // week 6 requirement for JSON parser
        rule {
            enabled = true
            element = 'CLASS'
            includes = ['edu.rice.json.Parser']

            limit {
                counter = 'INSTRUCTION'
                value = 'COVEREDRATIO'
                minimum = 0.85
            }
        }

        rule {
            enabled = true
            element = 'CLASS'
            includes = ['edu.rice.rpn.*']
            excludes = ['edu.rice.rpn.RPNCalcServer']

            limit {
                counter = 'INSTRUCTION'
                value = 'COVEREDRATIO'
                minimum = 0.85
            }
        }

        // pretty pictures, first week
        rule {
            enabled = true
            element = 'CLASS'
            includes = ['edu.rice.prettypictures.*']
            excludes = ['edu.rice.prettypictures.PrettyPicturesServer',
                        'edu.rice.prettypictures.ImprovedNoise']

            limit {
                counter = 'INSTRUCTION'
                value = 'COVEREDRATIO'
                minimum = 0.50
            }
        }

        // pretty pictures, second week
        rule {
            enabled = false
            element = 'CLASS'
            includes = ['edu.rice.prettypictures.*']
            excludes = ['edu.rice.prettypictures.PrettyPicturesServer',
                        'edu.rice.prettypictures.ImprovedNoise']

            limit {
                counter = 'INSTRUCTION'
                value = 'COVEREDRATIO'
                minimum = 0.80
            }
        }
    }
}

// Travis-CI runs 'gradle check'. This line makes the test coverage happen as part of 'gradle check'.
tasks.check.dependsOn jacocoTestCoverageVerification

////////////////////////////////////////////////////////////////////////////////
// This section specifies all the external libraries being used by your Java
// program and where to find them.
repositories {
    mavenCentral()

    maven {
        url "https://repository.apache.org/content/repositories/snapshots/" // we need this to get Apache Commons-Imaging
    }

}

dependencies {
    compile('com.sparkjava:spark-core:2.6.0') {
        exclude module: 'slf4j-simple' // because we're using logback instead
    }

    compile 'org.apache.commons:commons-text:1.1'
    compile 'org.apache.commons:commons-imaging:1.0-SNAPSHOT'
    compile 'ch.qos.logback:logback-classic:1.2.3'
    compile 'com.j2html:j2html:1.0.0'
    compile 'org.jetbrains:annotations:15.0'
    compile 'com.google.code.findbugs:jsr305:3.0.2'
    compile 'com.google.code.findbugs:annotations:3.0.1'
    compile 'com.google.errorprone:error_prone_annotations:2.0.21'

    testCompile 'org.mockito:mockito-core:2.10.0'
    testCompile 'junit:junit:4.12'
}
